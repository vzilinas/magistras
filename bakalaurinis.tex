\documentclass{VUMIFPSbakalaurinis}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{caption}
\usepackage{color}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subfig}
\usepackage{wrapfig}

\usepackage{enumitem}
\setitemize{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}
\setenumerate{noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt}

\hbadness=5000
% Titulinio aprašas
\university{Vilniaus universitetas}
\faculty{Matematikos ir informatikos fakultetas}
\department{Programų sistemų studijų programa}
\papertype{Mokslo tiriamasis darbas I}
\title{Srautinio apdorojimo sistemų balansavimas taikant mašininį mokymąsi}
\titleineng{Balancing stream processing systems using machine learning}
\author{Vytautas Žilinas}
\supervisor{Partn. doc. Andrius Adamonis}
\reviewer{Prof. dr. Aistis Raudys}
\date{Vilnius – \the\year}

% Nustatymai
% \setmainfont{Palemonas}   % Pakeisti teksto šriftą į Palemonas (turi būti įdiegtas sistemoje)
\bibliography{bibliografija}

\begin{document} 
\maketitle

\cleardoublepage\pagenumbering{arabic}
\setcounter{page}{2}

\section{Tyrimas}
\subsection{Tyrimo aktualumas ir naujumas}

Realaus laiko duomenų apdorojimas (angl. real-time data processing) yra jau senai nagrinėjamas kaip vienas iš būdų apdoroti didelių kiekių duomenis (angl. Big data). Vienas iš realaus laiko apdorojimo sprendimų yra srautinis duomenų apdorojimas. Srautinis duomenų apdorojimas (angl. stream processing) – lygiagrečių programų kūrimo modelis, pasireiškiantis sintaksiškai sujungiant nuoseklius skaičiavimo komponentus srautais, kad kiekvienas komponentas galėtų skaičiuoti savarankiškai \cite{shortstreamproc}. 

Yra keli pagrindiniai srautinio apdorojimo varikliai: „Apache Storm“, „Apache Spark“, „Heron“ ir kiti. „Heron“ srautinio apdorojimo variklis, kuris 2016 metais buvo išleistas „Twitter“, kaip alternatyva „Apache Storm“ srautinio apdorojimo varikliui \cite{openSourcing}. O „Apache Spark“ skiriasi nuo „Apache Storm“ ir „Heron“ tuo, kad jis apdoroja duomenis ne srautais, o mikro-paketais \cite{karau2015learning}. Šiame darbe bus naudojamas „Heron“, kadangi tai yra naujesnis ir geresnis srautinio apdorojimo variklis nei „Apache Storm“ \cite{twitterHeron}. Taip pat jo duomenų apdorojimo būdas yra kitoks nei „Apache Spark“, kurio balansavimas jau buvo atliktas naudojant mašininį mokymąsi \cite{vaquero2018autotuning}.

Srautinio apdorojimo sistemų balansavimas (angl. auto-tuning) - tai sistemos konfigūracijos valdymas siekiant užtikrinti geriausią resursų išnaudojimą - duomenų apdorojimas neprarandant greičio, bet ir tuo pačiu naudojant tik reikiamą kiekį resursų. Kadangi srautinio apdorojimo sistemos yra kuriamos lygiagrečios, todėl jos gali būti plečiamos horizontaliai ir vertikaliai \cite{shortstreamproc}, keičiant sistemų konfigūraciją. Tačiau lygiagrečių skaičiavimo vienetų keitimas nėra vienintelis būdas optimizuoti resursų išnaudojimą, kiekvienas variklis turi savo rinkinį konfigūruojamų elementų. Pavyzdžiui „Heron“ leidžia valdyti 56 skirtingus konfigūruojamus svertus (angl. levers) \cite{configDocument}.

Yra skirtingi būdai kaip gali būti parenkama tinkama konfigūracija. Kadangi nėra dar naudojimui pritaikytų sprendimų, kurie balansuotų srautinio apdorojimo sistemos dažniausiai tai daro duomenų inžinieriai, kurie dirba su šiomis sistemomis. Kadangi apkrovos gali būti skirtingų pobūdžiu (duomenų kiekis, skaičiavimų sudėtingumas, nereguliari apkrova), o inžinieriai konfigūruodami išbando keletą derinių ir pasirenka labiausiai tinkanti \cite{selfRegulatingStreaming}, lieka labai daug skirtingų neišbandytų konfigūracijos variacijų. Optimalios konfigūracijos suradimas yra NP sudėtingumo problema \cite{automateTuning}, todėl žmonėms yra sunku suvokti didelį kiekį konfigūracijos variacijų. 
Kitas būdas valdyti konfigūraciją buvo pasiūlytas 2017 metų straipsnyje „Dhalion: self-regulating stream processing in heron“, kur autoriai sukūrė sprendimą, kuris leidžia konfigūruoti „Heron“ srautinio apdorojimo sistemas pagal dabartinę situaciją, t.y. jei „Dhalion“ mato, jog apdorojimo elementų išnaudojimas yra >100\%, jis padidina lygiagrečiai dirbančių apdorojimo elementų kiekį \cite{dhalion}. Tačiau šis sprendimas leidžia reguliuoti tik elementų lygiagretumą ir tik reaguoti į resursų pokyčius.                         
Taip pat balansavimui gali būti pritaikytas mašininis mokymasis. Vienas iš tokių bandymų buvo aprašytas 2018 metų straipsnyje „Auto-tuning Distributed Stream Processing Systems using Reinforcement Learning“, kuriame buvo atliktas tyrimas: „Apache Spark“ sistemos balansavimui buvo naudojamas skatinamojo mokymo REINFORCE algoritmas, kuris pagal „Apache Spark“ duodamas sistemos metrikas keitė konfigūracijas ir buvo nustatyta, jog sprendimas naudojantis mašininį mokymąsi greičiau suranda geresne konfigūraciją nei žmogus per trumpesnį laiką ir taip pat sumažina laukimo trukme (angl. latency) 60-70\% palyginus su žmonių pasirinkta konfigūracija \cite{vaquero2018autotuning}. Šiame darbe naudojamas „Heron“ variklis leidžia prie savęs prijungti sukurta išorinę metrikų surinkimo programą, kuri gali rinkti tokias sistemų metrikas kaip: naudojama RAM atmintį, CPU apkrovą, komponentų paralelizmas ir kitas. 

Skatinamasis mokymasis yra vienas iš mašininio mokymosi sričių. Tai mokymasis, kuris nereikalauja duomenų apmokymui, o mokosi darant bandymus ir klystant ir pagrindinis uždavinys yra surasti balansą tarp naujų sprendimų tyrinėjimo (angl. exploration) ir turimos informacijos išnaudojimo (angl. exploitation) \cite{reinforcment}. Vienas iš pagrindinių privalumu naudojant skatinamąjį mokymąsi balansavimui yra tai, kad nereikia turėti išankstinių duomenų apmokymui. Tačiau tokio tipo mašininis mokymasis turi ir problemų: sudėtinga aprašyti teisingo sprendimo apdovanojimo funkciją ir turi būti teisingai aprašytas balansas tarp tyrinėjimo ir išnaudojimo  \cite{selfRegulatingStreaming}.

Yra sukurta daug skatinamojo mokymosi algoritmų (Monte Carl, Q-learning, Deep Q Network ir kiti), tad šiame darbe jie bus apžvelgti ir vienas iš jų bus pasirinktas ir pritaikytas išsikeltam uždaviniui. Algoritmas bus pasirinktas pagal tai, kuris bus tinkamiausias srautinių apdorojimų sistemų balansavimui.

\section{Darbas}

\subsection{Darbo tikslas}
Ištirti mašininio mokymosi tinkamumą srautinio apdorojimo sistemų balansavimui. 

\subsection{Uždaviniai}
\begin{enumerate}
    \item Pasirinkti srautinio apdorojimo sistemos metrikas, kurios bus naudojamos balansavimui.
    \item Išanalizuoti esamus skatinamojo mokymosi algoritmus ir pasirinkti bei pritaikyti tinkamą algoritmą srautinio apdorojimo sistemos balansavimui.
    \item Atlikti eksperimentą ir palyginti rezultatą su alternatyvomis - „Heron“ su standartine konfigūracija, „Heron“ su „Dhalion“ priedu bei „Heron“ balansavimas pritaikius REINFORCE algoritmą. 
\end{enumerate}

\subsection{Laukiami rezultatai}
\begin{enumerate}
    \item Pritaikant skirtingas apkrovas srautinio apdorojimo sistemoms, surinktos ir surikiuotos metrikos, reikalingos „Heron“ srautinio apdorojimo sistemos balansavimui. 
    \item Pasirinktas skatinamojo mokymosi algoritmas Deep Q Network ir pritaikytas „Heron“ srautinio apdorojimo sistemų balansavimui.
    \item Atliktas eksperimentas su „Heron“ ir alternatyvomis ir išanalizuoti bei palyginti gauti rezultatai.     
\end{enumerate}
 
\printbibliography[heading=bibintoc] 

\end{document}
